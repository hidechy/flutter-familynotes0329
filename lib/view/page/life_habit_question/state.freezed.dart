// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LifeHabitQuestionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)
        loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)?
        loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)?
        loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LifeHabitQuestionStateLoading value) loading,
    required TResult Function(LifeHabitQuestionStateLoaded value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LifeHabitQuestionStateLoading value)? loading,
    TResult? Function(LifeHabitQuestionStateLoaded value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LifeHabitQuestionStateLoading value)? loading,
    TResult Function(LifeHabitQuestionStateLoaded value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LifeHabitQuestionStateCopyWith<$Res> {
  factory $LifeHabitQuestionStateCopyWith(LifeHabitQuestionState value,
          $Res Function(LifeHabitQuestionState) then) =
      _$LifeHabitQuestionStateCopyWithImpl<$Res, LifeHabitQuestionState>;
}

/// @nodoc
class _$LifeHabitQuestionStateCopyWithImpl<$Res,
        $Val extends LifeHabitQuestionState>
    implements $LifeHabitQuestionStateCopyWith<$Res> {
  _$LifeHabitQuestionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LifeHabitQuestionStateLoadingCopyWith<$Res> {
  factory _$$LifeHabitQuestionStateLoadingCopyWith(
          _$LifeHabitQuestionStateLoading value,
          $Res Function(_$LifeHabitQuestionStateLoading) then) =
      __$$LifeHabitQuestionStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LifeHabitQuestionStateLoadingCopyWithImpl<$Res>
    extends _$LifeHabitQuestionStateCopyWithImpl<$Res,
        _$LifeHabitQuestionStateLoading>
    implements _$$LifeHabitQuestionStateLoadingCopyWith<$Res> {
  __$$LifeHabitQuestionStateLoadingCopyWithImpl(
      _$LifeHabitQuestionStateLoading _value,
      $Res Function(_$LifeHabitQuestionStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LifeHabitQuestionStateLoading implements LifeHabitQuestionStateLoading {
  const _$LifeHabitQuestionStateLoading();

  @override
  String toString() {
    return 'LifeHabitQuestionState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LifeHabitQuestionStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)
        loaded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)?
        loaded,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)?
        loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LifeHabitQuestionStateLoading value) loading,
    required TResult Function(LifeHabitQuestionStateLoaded value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LifeHabitQuestionStateLoading value)? loading,
    TResult? Function(LifeHabitQuestionStateLoaded value)? loaded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LifeHabitQuestionStateLoading value)? loading,
    TResult Function(LifeHabitQuestionStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LifeHabitQuestionStateLoading implements LifeHabitQuestionState {
  const factory LifeHabitQuestionStateLoading() =
      _$LifeHabitQuestionStateLoading;
}

/// @nodoc
abstract class _$$LifeHabitQuestionStateLoadedCopyWith<$Res> {
  factory _$$LifeHabitQuestionStateLoadedCopyWith(
          _$LifeHabitQuestionStateLoaded value,
          $Res Function(_$LifeHabitQuestionStateLoaded) then) =
      __$$LifeHabitQuestionStateLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<QuestionState> list, LifeHabitQuestionInputData inputData});

  $LifeHabitQuestionInputDataCopyWith<$Res> get inputData;
}

/// @nodoc
class __$$LifeHabitQuestionStateLoadedCopyWithImpl<$Res>
    extends _$LifeHabitQuestionStateCopyWithImpl<$Res,
        _$LifeHabitQuestionStateLoaded>
    implements _$$LifeHabitQuestionStateLoadedCopyWith<$Res> {
  __$$LifeHabitQuestionStateLoadedCopyWithImpl(
      _$LifeHabitQuestionStateLoaded _value,
      $Res Function(_$LifeHabitQuestionStateLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
    Object? inputData = null,
  }) {
    return _then(_$LifeHabitQuestionStateLoaded(
      list: null == list
          ? _value._list
          : list // ignore: cast_nullable_to_non_nullable
              as List<QuestionState>,
      inputData: null == inputData
          ? _value.inputData
          : inputData // ignore: cast_nullable_to_non_nullable
              as LifeHabitQuestionInputData,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LifeHabitQuestionInputDataCopyWith<$Res> get inputData {
    return $LifeHabitQuestionInputDataCopyWith<$Res>(_value.inputData, (value) {
      return _then(_value.copyWith(inputData: value));
    });
  }
}

/// @nodoc

class _$LifeHabitQuestionStateLoaded implements LifeHabitQuestionStateLoaded {
  const _$LifeHabitQuestionStateLoaded(
      {final List<QuestionState> list = const <QuestionState>[],
      this.inputData = const LifeHabitQuestionInputData()})
      : _list = list;

  final List<QuestionState> _list;
  @override
  @JsonKey()
  List<QuestionState> get list {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_list);
  }

  /// 入力内容
  @override
  @JsonKey()
  final LifeHabitQuestionInputData inputData;

  @override
  String toString() {
    return 'LifeHabitQuestionState.loaded(list: $list, inputData: $inputData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LifeHabitQuestionStateLoaded &&
            const DeepCollectionEquality().equals(other._list, _list) &&
            (identical(other.inputData, inputData) ||
                other.inputData == inputData));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_list), inputData);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LifeHabitQuestionStateLoadedCopyWith<_$LifeHabitQuestionStateLoaded>
      get copyWith => __$$LifeHabitQuestionStateLoadedCopyWithImpl<
          _$LifeHabitQuestionStateLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)
        loaded,
  }) {
    return loaded(list, inputData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)?
        loaded,
  }) {
    return loaded?.call(list, inputData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<QuestionState> list, LifeHabitQuestionInputData inputData)?
        loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(list, inputData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LifeHabitQuestionStateLoading value) loading,
    required TResult Function(LifeHabitQuestionStateLoaded value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LifeHabitQuestionStateLoading value)? loading,
    TResult? Function(LifeHabitQuestionStateLoaded value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LifeHabitQuestionStateLoading value)? loading,
    TResult Function(LifeHabitQuestionStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LifeHabitQuestionStateLoaded implements LifeHabitQuestionState {
  const factory LifeHabitQuestionStateLoaded(
          {final List<QuestionState> list,
          final LifeHabitQuestionInputData inputData}) =
      _$LifeHabitQuestionStateLoaded;

  List<QuestionState> get list;

  /// 入力内容
  LifeHabitQuestionInputData get inputData;
  @JsonKey(ignore: true)
  _$$LifeHabitQuestionStateLoadedCopyWith<_$LifeHabitQuestionStateLoaded>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$QuestionState {
  String get title => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;
  String get hint => throw _privateConstructorUsedError;
  String get assetName => throw _privateConstructorUsedError;
  List<ChoiceState> get choices => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $QuestionStateCopyWith<QuestionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionStateCopyWith<$Res> {
  factory $QuestionStateCopyWith(
          QuestionState value, $Res Function(QuestionState) then) =
      _$QuestionStateCopyWithImpl<$Res, QuestionState>;
  @useResult
  $Res call(
      {String title,
      String content,
      int id,
      String hint,
      String assetName,
      List<ChoiceState> choices});
}

/// @nodoc
class _$QuestionStateCopyWithImpl<$Res, $Val extends QuestionState>
    implements $QuestionStateCopyWith<$Res> {
  _$QuestionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? content = null,
    Object? id = null,
    Object? hint = null,
    Object? assetName = null,
    Object? choices = null,
  }) {
    return _then(_value.copyWith(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      hint: null == hint
          ? _value.hint
          : hint // ignore: cast_nullable_to_non_nullable
              as String,
      assetName: null == assetName
          ? _value.assetName
          : assetName // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChoiceState>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_QuestionStateCopyWith<$Res>
    implements $QuestionStateCopyWith<$Res> {
  factory _$$_QuestionStateCopyWith(
          _$_QuestionState value, $Res Function(_$_QuestionState) then) =
      __$$_QuestionStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String title,
      String content,
      int id,
      String hint,
      String assetName,
      List<ChoiceState> choices});
}

/// @nodoc
class __$$_QuestionStateCopyWithImpl<$Res>
    extends _$QuestionStateCopyWithImpl<$Res, _$_QuestionState>
    implements _$$_QuestionStateCopyWith<$Res> {
  __$$_QuestionStateCopyWithImpl(
      _$_QuestionState _value, $Res Function(_$_QuestionState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? content = null,
    Object? id = null,
    Object? hint = null,
    Object? assetName = null,
    Object? choices = null,
  }) {
    return _then(_$_QuestionState(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      hint: null == hint
          ? _value.hint
          : hint // ignore: cast_nullable_to_non_nullable
              as String,
      assetName: null == assetName
          ? _value.assetName
          : assetName // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChoiceState>,
    ));
  }
}

/// @nodoc

class _$_QuestionState implements _QuestionState {
  const _$_QuestionState(
      {required this.title,
      required this.content,
      required this.id,
      required this.hint,
      required this.assetName,
      required final List<ChoiceState> choices})
      : _choices = choices;

  @override
  final String title;
  @override
  final String content;
  @override
  final int id;
  @override
  final String hint;
  @override
  final String assetName;
  final List<ChoiceState> _choices;
  @override
  List<ChoiceState> get choices {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  @override
  String toString() {
    return 'QuestionState(title: $title, content: $content, id: $id, hint: $hint, assetName: $assetName, choices: $choices)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_QuestionState &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.hint, hint) || other.hint == hint) &&
            (identical(other.assetName, assetName) ||
                other.assetName == assetName) &&
            const DeepCollectionEquality().equals(other._choices, _choices));
  }

  @override
  int get hashCode => Object.hash(runtimeType, title, content, id, hint,
      assetName, const DeepCollectionEquality().hash(_choices));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_QuestionStateCopyWith<_$_QuestionState> get copyWith =>
      __$$_QuestionStateCopyWithImpl<_$_QuestionState>(this, _$identity);
}

abstract class _QuestionState implements QuestionState {
  const factory _QuestionState(
      {required final String title,
      required final String content,
      required final int id,
      required final String hint,
      required final String assetName,
      required final List<ChoiceState> choices}) = _$_QuestionState;

  @override
  String get title;
  @override
  String get content;
  @override
  int get id;
  @override
  String get hint;
  @override
  String get assetName;
  @override
  List<ChoiceState> get choices;
  @override
  @JsonKey(ignore: true)
  _$$_QuestionStateCopyWith<_$_QuestionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ChoiceState {
  int get id => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ChoiceStateCopyWith<ChoiceState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChoiceStateCopyWith<$Res> {
  factory $ChoiceStateCopyWith(
          ChoiceState value, $Res Function(ChoiceState) then) =
      _$ChoiceStateCopyWithImpl<$Res, ChoiceState>;
  @useResult
  $Res call({int id, String content});
}

/// @nodoc
class _$ChoiceStateCopyWithImpl<$Res, $Val extends ChoiceState>
    implements $ChoiceStateCopyWith<$Res> {
  _$ChoiceStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ChoiceStateCopyWith<$Res>
    implements $ChoiceStateCopyWith<$Res> {
  factory _$$_ChoiceStateCopyWith(
          _$_ChoiceState value, $Res Function(_$_ChoiceState) then) =
      __$$_ChoiceStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, String content});
}

/// @nodoc
class __$$_ChoiceStateCopyWithImpl<$Res>
    extends _$ChoiceStateCopyWithImpl<$Res, _$_ChoiceState>
    implements _$$_ChoiceStateCopyWith<$Res> {
  __$$_ChoiceStateCopyWithImpl(
      _$_ChoiceState _value, $Res Function(_$_ChoiceState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? content = null,
  }) {
    return _then(_$_ChoiceState(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ChoiceState implements _ChoiceState {
  const _$_ChoiceState({required this.id, required this.content});

  @override
  final int id;
  @override
  final String content;

  @override
  String toString() {
    return 'ChoiceState(id: $id, content: $content)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChoiceState &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ChoiceStateCopyWith<_$_ChoiceState> get copyWith =>
      __$$_ChoiceStateCopyWithImpl<_$_ChoiceState>(this, _$identity);
}

abstract class _ChoiceState implements ChoiceState {
  const factory _ChoiceState(
      {required final int id, required final String content}) = _$_ChoiceState;

  @override
  int get id;
  @override
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$_ChoiceStateCopyWith<_$_ChoiceState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LifeHabitQuestionInputData {
  /// 現在の設問index
  int get currentQuestionIndex => throw _privateConstructorUsedError;

  /// 現在の設問で選択中の選択肢id
  /// 未回答状態の場合はnull
  int? get currentChoiceId => throw _privateConstructorUsedError;

  /// 前の設問id
  int get previousQuestionId => throw _privateConstructorUsedError;

  /// 回答内容一覧
  List<AnswerState> get answers => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LifeHabitQuestionInputDataCopyWith<LifeHabitQuestionInputData>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LifeHabitQuestionInputDataCopyWith<$Res> {
  factory $LifeHabitQuestionInputDataCopyWith(LifeHabitQuestionInputData value,
          $Res Function(LifeHabitQuestionInputData) then) =
      _$LifeHabitQuestionInputDataCopyWithImpl<$Res,
          LifeHabitQuestionInputData>;
  @useResult
  $Res call(
      {int currentQuestionIndex,
      int? currentChoiceId,
      int previousQuestionId,
      List<AnswerState> answers});
}

/// @nodoc
class _$LifeHabitQuestionInputDataCopyWithImpl<$Res,
        $Val extends LifeHabitQuestionInputData>
    implements $LifeHabitQuestionInputDataCopyWith<$Res> {
  _$LifeHabitQuestionInputDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentQuestionIndex = null,
    Object? currentChoiceId = freezed,
    Object? previousQuestionId = null,
    Object? answers = null,
  }) {
    return _then(_value.copyWith(
      currentQuestionIndex: null == currentQuestionIndex
          ? _value.currentQuestionIndex
          : currentQuestionIndex // ignore: cast_nullable_to_non_nullable
              as int,
      currentChoiceId: freezed == currentChoiceId
          ? _value.currentChoiceId
          : currentChoiceId // ignore: cast_nullable_to_non_nullable
              as int?,
      previousQuestionId: null == previousQuestionId
          ? _value.previousQuestionId
          : previousQuestionId // ignore: cast_nullable_to_non_nullable
              as int,
      answers: null == answers
          ? _value.answers
          : answers // ignore: cast_nullable_to_non_nullable
              as List<AnswerState>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LifeHabitQuestionInputDataCopyWith<$Res>
    implements $LifeHabitQuestionInputDataCopyWith<$Res> {
  factory _$$_LifeHabitQuestionInputDataCopyWith(
          _$_LifeHabitQuestionInputData value,
          $Res Function(_$_LifeHabitQuestionInputData) then) =
      __$$_LifeHabitQuestionInputDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int currentQuestionIndex,
      int? currentChoiceId,
      int previousQuestionId,
      List<AnswerState> answers});
}

/// @nodoc
class __$$_LifeHabitQuestionInputDataCopyWithImpl<$Res>
    extends _$LifeHabitQuestionInputDataCopyWithImpl<$Res,
        _$_LifeHabitQuestionInputData>
    implements _$$_LifeHabitQuestionInputDataCopyWith<$Res> {
  __$$_LifeHabitQuestionInputDataCopyWithImpl(
      _$_LifeHabitQuestionInputData _value,
      $Res Function(_$_LifeHabitQuestionInputData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentQuestionIndex = null,
    Object? currentChoiceId = freezed,
    Object? previousQuestionId = null,
    Object? answers = null,
  }) {
    return _then(_$_LifeHabitQuestionInputData(
      currentQuestionIndex: null == currentQuestionIndex
          ? _value.currentQuestionIndex
          : currentQuestionIndex // ignore: cast_nullable_to_non_nullable
              as int,
      currentChoiceId: freezed == currentChoiceId
          ? _value.currentChoiceId
          : currentChoiceId // ignore: cast_nullable_to_non_nullable
              as int?,
      previousQuestionId: null == previousQuestionId
          ? _value.previousQuestionId
          : previousQuestionId // ignore: cast_nullable_to_non_nullable
              as int,
      answers: null == answers
          ? _value._answers
          : answers // ignore: cast_nullable_to_non_nullable
              as List<AnswerState>,
    ));
  }
}

/// @nodoc

class _$_LifeHabitQuestionInputData implements _LifeHabitQuestionInputData {
  const _$_LifeHabitQuestionInputData(
      {this.currentQuestionIndex = 0,
      this.currentChoiceId,
      this.previousQuestionId = 0,
      final List<AnswerState> answers = const <AnswerState>[]})
      : _answers = answers;

  /// 現在の設問index
  @override
  @JsonKey()
  final int currentQuestionIndex;

  /// 現在の設問で選択中の選択肢id
  /// 未回答状態の場合はnull
  @override
  final int? currentChoiceId;

  /// 前の設問id
  @override
  @JsonKey()
  final int previousQuestionId;

  /// 回答内容一覧
  final List<AnswerState> _answers;

  /// 回答内容一覧
  @override
  @JsonKey()
  List<AnswerState> get answers {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_answers);
  }

  @override
  String toString() {
    return 'LifeHabitQuestionInputData(currentQuestionIndex: $currentQuestionIndex, currentChoiceId: $currentChoiceId, previousQuestionId: $previousQuestionId, answers: $answers)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LifeHabitQuestionInputData &&
            (identical(other.currentQuestionIndex, currentQuestionIndex) ||
                other.currentQuestionIndex == currentQuestionIndex) &&
            (identical(other.currentChoiceId, currentChoiceId) ||
                other.currentChoiceId == currentChoiceId) &&
            (identical(other.previousQuestionId, previousQuestionId) ||
                other.previousQuestionId == previousQuestionId) &&
            const DeepCollectionEquality().equals(other._answers, _answers));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      currentQuestionIndex,
      currentChoiceId,
      previousQuestionId,
      const DeepCollectionEquality().hash(_answers));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LifeHabitQuestionInputDataCopyWith<_$_LifeHabitQuestionInputData>
      get copyWith => __$$_LifeHabitQuestionInputDataCopyWithImpl<
          _$_LifeHabitQuestionInputData>(this, _$identity);
}

abstract class _LifeHabitQuestionInputData
    implements LifeHabitQuestionInputData {
  const factory _LifeHabitQuestionInputData(
      {final int currentQuestionIndex,
      final int? currentChoiceId,
      final int previousQuestionId,
      final List<AnswerState> answers}) = _$_LifeHabitQuestionInputData;

  @override

  /// 現在の設問index
  int get currentQuestionIndex;
  @override

  /// 現在の設問で選択中の選択肢id
  /// 未回答状態の場合はnull
  int? get currentChoiceId;
  @override

  /// 前の設問id
  int get previousQuestionId;
  @override

  /// 回答内容一覧
  List<AnswerState> get answers;
  @override
  @JsonKey(ignore: true)
  _$$_LifeHabitQuestionInputDataCopyWith<_$_LifeHabitQuestionInputData>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnswerState {
  /// 設問id
  int get questionId => throw _privateConstructorUsedError;

  /// 選択肢id
  int get choiceId => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnswerStateCopyWith<AnswerState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerStateCopyWith<$Res> {
  factory $AnswerStateCopyWith(
          AnswerState value, $Res Function(AnswerState) then) =
      _$AnswerStateCopyWithImpl<$Res, AnswerState>;
  @useResult
  $Res call({int questionId, int choiceId});
}

/// @nodoc
class _$AnswerStateCopyWithImpl<$Res, $Val extends AnswerState>
    implements $AnswerStateCopyWith<$Res> {
  _$AnswerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? questionId = null,
    Object? choiceId = null,
  }) {
    return _then(_value.copyWith(
      questionId: null == questionId
          ? _value.questionId
          : questionId // ignore: cast_nullable_to_non_nullable
              as int,
      choiceId: null == choiceId
          ? _value.choiceId
          : choiceId // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AnsewerStateCopyWith<$Res>
    implements $AnswerStateCopyWith<$Res> {
  factory _$$_AnsewerStateCopyWith(
          _$_AnsewerState value, $Res Function(_$_AnsewerState) then) =
      __$$_AnsewerStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int questionId, int choiceId});
}

/// @nodoc
class __$$_AnsewerStateCopyWithImpl<$Res>
    extends _$AnswerStateCopyWithImpl<$Res, _$_AnsewerState>
    implements _$$_AnsewerStateCopyWith<$Res> {
  __$$_AnsewerStateCopyWithImpl(
      _$_AnsewerState _value, $Res Function(_$_AnsewerState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? questionId = null,
    Object? choiceId = null,
  }) {
    return _then(_$_AnsewerState(
      questionId: null == questionId
          ? _value.questionId
          : questionId // ignore: cast_nullable_to_non_nullable
              as int,
      choiceId: null == choiceId
          ? _value.choiceId
          : choiceId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_AnsewerState implements _AnsewerState {
  const _$_AnsewerState({required this.questionId, required this.choiceId});

  /// 設問id
  @override
  final int questionId;

  /// 選択肢id
  @override
  final int choiceId;

  @override
  String toString() {
    return 'AnswerState(questionId: $questionId, choiceId: $choiceId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnsewerState &&
            (identical(other.questionId, questionId) ||
                other.questionId == questionId) &&
            (identical(other.choiceId, choiceId) ||
                other.choiceId == choiceId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, questionId, choiceId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AnsewerStateCopyWith<_$_AnsewerState> get copyWith =>
      __$$_AnsewerStateCopyWithImpl<_$_AnsewerState>(this, _$identity);
}

abstract class _AnsewerState implements AnswerState {
  const factory _AnsewerState(
      {required final int questionId,
      required final int choiceId}) = _$_AnsewerState;

  @override

  /// 設問id
  int get questionId;
  @override

  /// 選択肢id
  int get choiceId;
  @override
  @JsonKey(ignore: true)
  _$$_AnsewerStateCopyWith<_$_AnsewerState> get copyWith =>
      throw _privateConstructorUsedError;
}
